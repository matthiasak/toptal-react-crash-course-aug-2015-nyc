//
// HELPER CODE
//
// so I can inject
//
// - external scripts, and
// - CSS generated by Sass
//
// into the iframe on the right
//
const qs = (s, el) => (el || document).querySelector(s)
const loadScripts = (...urls) => Promise.all(
    urls.map(url => {
        let s = document.createElement('script')
        s.src = url
        document.body.appendChild(s)
        return new Promise((res,rej) => s.onload = res)
    })
)

const createStylesheet = () => {
    let style = document.createElement('style')
    Sass.compile(css, result => {
        style.textContent = result.text
        qs('head').appendChild(style)
    })
}

window.onload = loadScripts(
    'https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.min.js',
'https://medialize.github.io/sass.js/dist/sass.sync.js'
).then(_ => createStylesheet()).then(() => init()).catch(e => log(e))

const css = `
body {
    background: green;
    color: white;
    padding:1.5rem;
}
`

//
// END HELPER CODE - START APP
//

let init = function(){

    let {Component} = React

    class Clock extends Component {
        constructor(...p){
            super(...p)
            this.state = {
                time: new Date()
            }
        }

        // custom methods added to this component...
        // given an underscore in the name to denote 'custom'
        // (not required, by encouraged)
        _setTime() {
            let dommy = this.refs.dommy,
                node = React.findDOMNode(dommy)
            // log(node.innerText+'')
            this.setState({ time: new Date })
        }

        // THE "WILLS"
        //
        // called when a component is attached to the DOM
        componentWillMount() {}
        // called when props are updated
        componentWillReceiveProps() {}
        // called when a component is removed from the DOM
        componentWillUnmount() {}
        // called before the component is re-rendered
        componentWillUpdate(nextProps, nextState) {}

        // THE "DIDS"
        //
        // called after a component is attached to the DOM
        componentDidMount() {
            this.interval = setInterval(() => this._setTime(), 1000)
        }
        // called after props are updated
        componentDidReceiveProps() {}
        // called after a component is removed from the DOM
        componentDidUnmount() {
            clearInterval(this.interval)
        }
        // called when the component did update
        componentDidUpdate(prevProps, prevState) {}

        // THE "SHOULDS"
        //
        // if returns true, re-renders, otherwise nothing happens
        // shouldComponentUpdate(nextState, nextProps) {}

        // called by React whenever the state changes or forceUpdate() is called
        render(){
            // by dynamically allowing components to be injected inside Clock
            // we create an "HOC" (a Higher Order Component)
            //
            // many awesome projects like React Router, React Resolver,
            // React Motion, etc are enabled by this ability

            return <div>
                <p ref="dommy">{this.props.message}</p>
                <p>time: { this.state.time.toTimeString() }</p>
                {this.props.children}
            </div>
        }
    }

    Clock.displayName = 'Clock'
    Clock.defaultProps = { message: "Let's get some lunch." }

    // log(<Clock message={'Coffee time after this!'} />, new Date)
    // React.render(
    //     <Clock>
    //         <p>Oh, did I sneak this in here?</p>
    //     </Clock>,
    // qs('body'))
}

